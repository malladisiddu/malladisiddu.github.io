<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FwordCTF 2020 | Siddartha's Blog</title><meta name=keywords content="LCG,PRNG"><meta name=description content="I thoroughly enjoyed playing FwordCTF-2020, but I could manage to play only for 7 hours.
Randomness Randomness.py
Given an encryption file in which the output is commented,
from Crypto.Util.number import * from random import * flag=&#34;TODO&#34; p=getPrime(64) a=getrandbits(64) b=getrandbits(64) X=[] X.append((a*getrandbits(64)+b)%p) c=0 while c<len(flag): X.append((a*X[c]+b)%p) c+=1 output=[] for i in range(len(flag)): output.append(ord(flag[i])^X[i]) print (output) #output:[6680465291011788243L, 5100570103593250421L, 5906808313299165060L, 1965917782737693358L, 9056785591048864624L, 1829758495155458576L, 6790868899161600055L, 1596515234863242823L, 1542626304251881891L, 8104506805098882719L, 1007224930233032567L, 3734079115803760073L, 7849173324645439452L, 8732100672289854567L, 5175836768003400781L, 1424151033239111460L, 1199105222454059911L, 1664215650827157105L, 9008386209424299800L, 484211781780518254L, 2512932525834758909L, 270126439443651096L, 3183206577049996011L, 3279047721488346724L, 3454276445316959481L, 2818682432513461896L, 1198230090827197024L, 6998819122186572678L, 9203565046169681246L, 2238598386754583423L, 467098371562174956L, 5653529053698720276L, 2015452976526330232L, 2551998512666399199L, 7069788985925185031L, 5960242873564733830L, 8674335448210427234L, 8831855692621741517L, 6943582577462564728L, 2159276184039111694L, 8688468346396385461L, 440650407436900405L, 6995840816131325250L, 4637034747767556143L, 3074066864500201630L, 3089580429060692934L, 2636919931902761401L, 5048459994558771200L, 6575450200614822046L, 666932631675155892L, 3355067815387388102L, 3494943856508019168L, 3208598838604422062L, 1651654978658074504L, 1031697828323732832L, 3522460087077276636L, 6871524519121580258L, 6523448658792083486L, 127306226106122213L, 147467006327822722L, 3241736541061054362L, 8781435214433157730L, 7267936298215752831L, 3411059229428517472L, 6597995245035183751L, 1256684894889830824L, 6272257692365676430L, 303437276610446361L, 8730871523914292433L, 6472487383860532571L, 5022165523149187811L, 4462701447753878703L, 1590013093628585660L, 4874224067795612706L] The idea to solve the challenge is very simple, if we can find X and XOR it with the given output we get the flag."><meta name=author content="Siddartha Malladi"><link rel=canonical href=https://malladisiddu.github.io/posts/fwordctf-2020-writeups/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://malladisiddu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://malladisiddu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://malladisiddu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://malladisiddu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://malladisiddu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="FwordCTF 2020"><meta property="og:description" content="I thoroughly enjoyed playing FwordCTF-2020, but I could manage to play only for 7 hours.
Randomness Randomness.py
Given an encryption file in which the output is commented,
from Crypto.Util.number import * from random import * flag=&#34;TODO&#34; p=getPrime(64) a=getrandbits(64) b=getrandbits(64) X=[] X.append((a*getrandbits(64)+b)%p) c=0 while c<len(flag): X.append((a*X[c]+b)%p) c+=1 output=[] for i in range(len(flag)): output.append(ord(flag[i])^X[i]) print (output) #output:[6680465291011788243L, 5100570103593250421L, 5906808313299165060L, 1965917782737693358L, 9056785591048864624L, 1829758495155458576L, 6790868899161600055L, 1596515234863242823L, 1542626304251881891L, 8104506805098882719L, 1007224930233032567L, 3734079115803760073L, 7849173324645439452L, 8732100672289854567L, 5175836768003400781L, 1424151033239111460L, 1199105222454059911L, 1664215650827157105L, 9008386209424299800L, 484211781780518254L, 2512932525834758909L, 270126439443651096L, 3183206577049996011L, 3279047721488346724L, 3454276445316959481L, 2818682432513461896L, 1198230090827197024L, 6998819122186572678L, 9203565046169681246L, 2238598386754583423L, 467098371562174956L, 5653529053698720276L, 2015452976526330232L, 2551998512666399199L, 7069788985925185031L, 5960242873564733830L, 8674335448210427234L, 8831855692621741517L, 6943582577462564728L, 2159276184039111694L, 8688468346396385461L, 440650407436900405L, 6995840816131325250L, 4637034747767556143L, 3074066864500201630L, 3089580429060692934L, 2636919931902761401L, 5048459994558771200L, 6575450200614822046L, 666932631675155892L, 3355067815387388102L, 3494943856508019168L, 3208598838604422062L, 1651654978658074504L, 1031697828323732832L, 3522460087077276636L, 6871524519121580258L, 6523448658792083486L, 127306226106122213L, 147467006327822722L, 3241736541061054362L, 8781435214433157730L, 7267936298215752831L, 3411059229428517472L, 6597995245035183751L, 1256684894889830824L, 6272257692365676430L, 303437276610446361L, 8730871523914292433L, 6472487383860532571L, 5022165523149187811L, 4462701447753878703L, 1590013093628585660L, 4874224067795612706L] The idea to solve the challenge is very simple, if we can find X and XOR it with the given output we get the flag."><meta property="og:type" content="article"><meta property="og:url" content="https://malladisiddu.github.io/posts/fwordctf-2020-writeups/"><meta property="og:image" content="https://malladisiddu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-30T00:00:00+00:00"><meta property="article:modified_time" content="2020-08-30T00:00:00+00:00"><meta property="og:site_name" content="Siddartha's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://malladisiddu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="FwordCTF 2020"><meta name=twitter:description content="I thoroughly enjoyed playing FwordCTF-2020, but I could manage to play only for 7 hours.
Randomness Randomness.py
Given an encryption file in which the output is commented,
from Crypto.Util.number import * from random import * flag=&#34;TODO&#34; p=getPrime(64) a=getrandbits(64) b=getrandbits(64) X=[] X.append((a*getrandbits(64)+b)%p) c=0 while c<len(flag): X.append((a*X[c]+b)%p) c+=1 output=[] for i in range(len(flag)): output.append(ord(flag[i])^X[i]) print (output) #output:[6680465291011788243L, 5100570103593250421L, 5906808313299165060L, 1965917782737693358L, 9056785591048864624L, 1829758495155458576L, 6790868899161600055L, 1596515234863242823L, 1542626304251881891L, 8104506805098882719L, 1007224930233032567L, 3734079115803760073L, 7849173324645439452L, 8732100672289854567L, 5175836768003400781L, 1424151033239111460L, 1199105222454059911L, 1664215650827157105L, 9008386209424299800L, 484211781780518254L, 2512932525834758909L, 270126439443651096L, 3183206577049996011L, 3279047721488346724L, 3454276445316959481L, 2818682432513461896L, 1198230090827197024L, 6998819122186572678L, 9203565046169681246L, 2238598386754583423L, 467098371562174956L, 5653529053698720276L, 2015452976526330232L, 2551998512666399199L, 7069788985925185031L, 5960242873564733830L, 8674335448210427234L, 8831855692621741517L, 6943582577462564728L, 2159276184039111694L, 8688468346396385461L, 440650407436900405L, 6995840816131325250L, 4637034747767556143L, 3074066864500201630L, 3089580429060692934L, 2636919931902761401L, 5048459994558771200L, 6575450200614822046L, 666932631675155892L, 3355067815387388102L, 3494943856508019168L, 3208598838604422062L, 1651654978658074504L, 1031697828323732832L, 3522460087077276636L, 6871524519121580258L, 6523448658792083486L, 127306226106122213L, 147467006327822722L, 3241736541061054362L, 8781435214433157730L, 7267936298215752831L, 3411059229428517472L, 6597995245035183751L, 1256684894889830824L, 6272257692365676430L, 303437276610446361L, 8730871523914292433L, 6472487383860532571L, 5022165523149187811L, 4462701447753878703L, 1590013093628585660L, 4874224067795612706L] The idea to solve the challenge is very simple, if we can find X and XOR it with the given output we get the flag."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://malladisiddu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"FwordCTF 2020","item":"https://malladisiddu.github.io/posts/fwordctf-2020-writeups/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FwordCTF 2020","name":"FwordCTF 2020","description":"I thoroughly enjoyed playing FwordCTF-2020, but I could manage to play only for 7 hours.\nRandomness Randomness.py\nGiven an encryption file in which the output is commented,\nfrom Crypto.Util.number import * from random import * flag=\u0026#34;TODO\u0026#34; p=getPrime(64) a=getrandbits(64) b=getrandbits(64) X=[] X.append((a*getrandbits(64)+b)%p) c=0 while c\u0026lt;len(flag): X.append((a*X[c]+b)%p) c+=1 output=[] for i in range(len(flag)): output.append(ord(flag[i])^X[i]) print (output) #output:[6680465291011788243L, 5100570103593250421L, 5906808313299165060L, 1965917782737693358L, 9056785591048864624L, 1829758495155458576L, 6790868899161600055L, 1596515234863242823L, 1542626304251881891L, 8104506805098882719L, 1007224930233032567L, 3734079115803760073L, 7849173324645439452L, 8732100672289854567L, 5175836768003400781L, 1424151033239111460L, 1199105222454059911L, 1664215650827157105L, 9008386209424299800L, 484211781780518254L, 2512932525834758909L, 270126439443651096L, 3183206577049996011L, 3279047721488346724L, 3454276445316959481L, 2818682432513461896L, 1198230090827197024L, 6998819122186572678L, 9203565046169681246L, 2238598386754583423L, 467098371562174956L, 5653529053698720276L, 2015452976526330232L, 2551998512666399199L, 7069788985925185031L, 5960242873564733830L, 8674335448210427234L, 8831855692621741517L, 6943582577462564728L, 2159276184039111694L, 8688468346396385461L, 440650407436900405L, 6995840816131325250L, 4637034747767556143L, 3074066864500201630L, 3089580429060692934L, 2636919931902761401L, 5048459994558771200L, 6575450200614822046L, 666932631675155892L, 3355067815387388102L, 3494943856508019168L, 3208598838604422062L, 1651654978658074504L, 1031697828323732832L, 3522460087077276636L, 6871524519121580258L, 6523448658792083486L, 127306226106122213L, 147467006327822722L, 3241736541061054362L, 8781435214433157730L, 7267936298215752831L, 3411059229428517472L, 6597995245035183751L, 1256684894889830824L, 6272257692365676430L, 303437276610446361L, 8730871523914292433L, 6472487383860532571L, 5022165523149187811L, 4462701447753878703L, 1590013093628585660L, 4874224067795612706L] The idea to solve the challenge is very simple, if we can find X and XOR it with the given output we get the flag.","keywords":["LCG","PRNG"],"articleBody":" I thoroughly enjoyed playing FwordCTF-2020, but I could manage to play only for 7 hours.\nRandomness Randomness.py\nGiven an encryption file in which the output is commented,\nfrom Crypto.Util.number import * from random import * flag=\"TODO\" p=getPrime(64) a=getrandbits(64) b=getrandbits(64) X=[] X.append((a*getrandbits(64)+b)%p) c=0 while c\u003clen(flag): X.append((a*X[c]+b)%p) c+=1 output=[] for i in range(len(flag)): output.append(ord(flag[i])^X[i]) print (output) #output:[6680465291011788243L, 5100570103593250421L, 5906808313299165060L, 1965917782737693358L, 9056785591048864624L, 1829758495155458576L, 6790868899161600055L, 1596515234863242823L, 1542626304251881891L, 8104506805098882719L, 1007224930233032567L, 3734079115803760073L, 7849173324645439452L, 8732100672289854567L, 5175836768003400781L, 1424151033239111460L, 1199105222454059911L, 1664215650827157105L, 9008386209424299800L, 484211781780518254L, 2512932525834758909L, 270126439443651096L, 3183206577049996011L, 3279047721488346724L, 3454276445316959481L, 2818682432513461896L, 1198230090827197024L, 6998819122186572678L, 9203565046169681246L, 2238598386754583423L, 467098371562174956L, 5653529053698720276L, 2015452976526330232L, 2551998512666399199L, 7069788985925185031L, 5960242873564733830L, 8674335448210427234L, 8831855692621741517L, 6943582577462564728L, 2159276184039111694L, 8688468346396385461L, 440650407436900405L, 6995840816131325250L, 4637034747767556143L, 3074066864500201630L, 3089580429060692934L, 2636919931902761401L, 5048459994558771200L, 6575450200614822046L, 666932631675155892L, 3355067815387388102L, 3494943856508019168L, 3208598838604422062L, 1651654978658074504L, 1031697828323732832L, 3522460087077276636L, 6871524519121580258L, 6523448658792083486L, 127306226106122213L, 147467006327822722L, 3241736541061054362L, 8781435214433157730L, 7267936298215752831L, 3411059229428517472L, 6597995245035183751L, 1256684894889830824L, 6272257692365676430L, 303437276610446361L, 8730871523914292433L, 6472487383860532571L, 5022165523149187811L, 4462701447753878703L, 1590013093628585660L, 4874224067795612706L] The idea to solve the challenge is very simple, if we can find X and XOR it with the given output we get the flag.\nAfter going through the code, I got to know that it involves randombits, the topic which I’ve never solved any challenge based on it. But I know that it is related to Pseudo Random Number Generator(PRNG). Anyways, lets break the code into parts and understand it. First lets understand the final part of the code,\noutput=[] for i in range(len(flag)): output.append(ord(flag[i])^X[i]) print (output) We understood that, flag and an array X were XORed and appended to output array. Here, we only know output, X \u0026 flag are yet to be found. Guess what? Since we know the flag format we can find some values of X,\nflag = \"FwordCTF{\" output = [6680465291011788243, 5100570103593250421, 5906808313299165060, 1965917782737693358, 9056785591048864624, 1829758495155458576, 6790868899161600055, 1596515234863242823, 1542626304251881891, 8104506805098882719, 1007224930233032567, 3734079115803760073, 7849173324645439452, 8732100672289854567, 5175836768003400781, 1424151033239111460, 1199105222454059911, 1664215650827157105, 9008386209424299800, 484211781780518254, 2512932525834758909, 270126439443651096, 3183206577049996011, 3279047721488346724, 3454276445316959481, 2818682432513461896, 1198230090827197024, 6998819122186572678, 9203565046169681246, 2238598386754583423, 467098371562174956, 5653529053698720276, 2015452976526330232, 2551998512666399199, 7069788985925185031, 5960242873564733830, 8674335448210427234, 8831855692621741517, 6943582577462564728, 2159276184039111694, 8688468346396385461, 440650407436900405, 6995840816131325250, 4637034747767556143, 3074066864500201630, 3089580429060692934, 2636919931902761401, 5048459994558771200, 6575450200614822046, 666932631675155892, 3355067815387388102, 3494943856508019168, 3208598838604422062, 1651654978658074504, 1031697828323732832, 3522460087077276636, 6871524519121580258, 6523448658792083486, 127306226106122213, 147467006327822722, 3241736541061054362, 8781435214433157730, 7267936298215752831, 3411059229428517472, 6597995245035183751, 1256684894889830824, 6272257692365676430, 303437276610446361, 8730871523914292433, 6472487383860532571,5022165523149187811, 4462701447753878703, 1590013093628585660, 4874224067795612706] X = [] for i in range(len(flag)): X.append(ord(flag[i])^output[i]) Here is the output,\nIn [2]: X Out[2]: [6680465291011788181, 5100570103593250306, 5906808313299165163, 1965917782737693404, 9056785591048864532, 1829758495155458643, 6790868899161600099, 1596515234863242753, 1542626304251881944] Now lets find the remaining values of X by analysing the code involved in forming it,\np=getPrime(64) a=getrandbits(64) b=getrandbits(64) X=[] X.append((a*getrandbits(64)+b)%p) c=0 while c\u003clen(flag): X.append((a*X[c]+b)%p) c+=1 We understood that p is a random prime number, a \u0026 b are any two random numbers. Also we can understand that, this a*getrandbits(64)+b)%p is the part which is producing X[i]. But at first it seeded an initial value into X. Now, for any noob like me two questions will arise,\n[1] What is the type of PRNG used?\n[2] How to crack it?\nSo, I have googled for list of PRNG’s. I got the list here. My idea is to google each Random Number Generator(RNG) and finding similarity to our code. Fortunately, I found it. It is Linear Congruential Generator(LCG).\nThis equation confirmed me that it is an LCG,\n$$ (X_{n+1}) = (aX_{n}+c)\\pmod m $$\nCracking LCG I have referred to many articles to find the answer for the 2nd question, and I got to know that LCG is the easiest of all PRNG’s for both implementing \u0026 cracking. Let’s crack it, Let us understand the terminology here,\np - modulus\na - multiplier\nb - increment\nUnfortunately, We don’t the values of all the three. Let us understand this a*getrandbits(64)+b)%p working,\ns1 = s0*a + b (mod p) s2 = s1*a + b (mod p) s3 = s2*a + b (mod p) Its feeding back the intial seed to find the next one. Next one to find the next one \u0026 so on. Let us rearrange the equations a bit,\ns1 - (s0*a + b) = k_1 * p s2 - (s1*a + b) = k_2 * p s3 - (s2*a + b) = k_3 * p Its unreal to solve 3 equations with 6 unknowns, but number theory made it real by using simple property i.e., if we have few random multiples of p, with large probability their gcd will be equal to p. Let us manipulate the above equations a bit,\nt0 = s1 - s0 t1 = s2 - s1 = (s1*a + b) - (s0*a + b) = a*(s1 - s0) = a*t0 (mod p) t2 = s3 - s2 = (s2*a + b) - (s1*a + b) = a*(s2 - s1) = a*t1 (mod p) t3 = s4 - s3 = (s3*a + b) - (s2*a + b) = a*(s3 - s2) = a*t2 (mod p) Final equation to solve this is,\nt2*t0 - t1*t1 = (a*a*t0 * t0) - (a*t0 * a*t0) = 0 (mod p) Let us define python function to crack the modulus,\ndef crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return modulus Now we got the modulus, its pretty simple to find multiplier \u0026 increment. Let us consider the first two equations and subtract them\ns1 = x0*a + b (mod p) s_2 = x1*a + b (mod p) s_2 - s_1 = s1*a - s0*a (mod p) s_2 - s_1 = a*(s1 - s0) (mod p) a = (s_2 - s_1)/(s_1 - s_0) (mod p) that’s it we got a and now b can be retrieved by by using only one equation as we know all other values in the equation. Consider the first equation,\ns1 = s0*a + b (mod p) After rearranging,\nb = s1 - s0*a (mod p) Let us put this in a function,\ndef crack_lcg(seeds): a = ((seeds[2] - seeds[1]) * invert(seeds[1] - seeds[0], p)) % p return a, (seeds[1] - seeds[0]*a) % p Final Exploit Wrapping up everything from all the understanding we got from the above discussion,\nfrom functools import reduce from gmpy2 import gcd,gcdext,invert def crack_lcg(seeds): a = ((seeds[2] - seeds[1]) * invert(seeds[1] - seeds[0], p)) % p return a, (seeds[1] - seeds[0]*a) % p def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return modulus flag = \"FwordCTF{\" output = [6680465291011788243, 5100570103593250421, 5906808313299165060, 1965917782737693358, 9056785591048864624, 1829758495155458576, 6790868899161600055, 1596515234863242823, 1542626304251881891, 8104506805098882719, 1007224930233032567, 3734079115803760073, 7849173324645439452, 8732100672289854567, 5175836768003400781, 1424151033239111460, 1199105222454059911, 1664215650827157105, 9008386209424299800, 484211781780518254, 2512932525834758909, 270126439443651096, 3183206577049996011, 3279047721488346724, 3454276445316959481, 2818682432513461896, 1198230090827197024, 6998819122186572678, 9203565046169681246, 2238598386754583423, 467098371562174956, 5653529053698720276, 2015452976526330232, 2551998512666399199, 7069788985925185031, 5960242873564733830, 8674335448210427234, 8831855692621741517, 6943582577462564728, 2159276184039111694, 8688468346396385461, 440650407436900405, 6995840816131325250, 4637034747767556143, 3074066864500201630, 3089580429060692934, 2636919931902761401, 5048459994558771200, 6575450200614822046, 666932631675155892, 3355067815387388102, 3494943856508019168, 3208598838604422062, 1651654978658074504, 1031697828323732832, 3522460087077276636, 6871524519121580258, 6523448658792083486, 127306226106122213, 147467006327822722, 3241736541061054362, 8781435214433157730, 7267936298215752831, 3411059229428517472, 6597995245035183751, 1256684894889830824, 6272257692365676430, 303437276610446361, 8730871523914292433, 6472487383860532571,5022165523149187811, 4462701447753878703, 1590013093628585660, 4874224067795612706] X = [] for i in range(len(flag)): X.append(ord(flag[i])^output[i]) p = crack_unknown_modulus(X) a, b = crack_lcg(X) for i in range(1,len(X)): assert X[i] == (X[i-1]*a + b) % p s = [] s.append(X[0]) for i in range(1,len(output)): s.append((s[i-1]*a + b)%p) flag = \"\" for i in range(len(output)): flag+= chr(s[i]^output[i]) print(\"[+] Flag: \",flag) Flag: FwordCTF{LCG_easy_to_break!That_was_a_mistake_choosing_it_as_a_secure_way}\nYou can find my entire exploit here. If you have any queries, feedback, suggestions either you can put them in comment section or you can ping me via twitter @st0ic3r.\nAlright, See you next time\nBu, Bye !\n","wordCount":"1205","inLanguage":"en","datePublished":"2020-08-30T00:00:00Z","dateModified":"2020-08-30T00:00:00Z","author":{"@type":"Person","name":"Siddartha Malladi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://malladisiddu.github.io/posts/fwordctf-2020-writeups/"},"publisher":{"@type":"Organization","name":"Siddartha's Blog","logo":{"@type":"ImageObject","url":"https://malladisiddu.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://malladisiddu.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://malladisiddu.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://malladisiddu.github.io/media-coverage/ title="Media Coverage"><span>Media Coverage</span></a></li><li><a href=https://malladisiddu.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://malladisiddu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://malladisiddu.github.io/posts/>Posts</a></div><h1 class=post-title>FwordCTF 2020</h1><div class=post-meta><span title='2020-08-30 00:00:00 +0000 UTC'>August 30, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Siddartha Malladi</div></header><div class=post-content><p><img loading=lazy src=https://ctftime.org/media/events/logo-twitter.png alt=logo></p><p>I thoroughly enjoyed playing FwordCTF-2020, but I could manage to play only for 7 hours.</p><h2 id=randomness>Randomness<a hidden class=anchor aria-hidden=true href=#randomness>#</a></h2><blockquote><p><a href=https://github.com/malladisiddu/Crypto-writeups/blob/master/FwordCTF/Randomness/Randomness.py>Randomness.py</a></p></blockquote><p>Given an encryption file in which the output is commented,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.Util.number <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> random <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>flag<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;TODO&#34;</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>=</span>getPrime(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>a<span style=color:#f92672>=</span>getrandbits(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>b<span style=color:#f92672>=</span>getrandbits(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>X<span style=color:#f92672>=</span>[]
</span></span><span style=display:flex><span>X<span style=color:#f92672>.</span>append((a<span style=color:#f92672>*</span>getrandbits(<span style=color:#ae81ff>64</span>)<span style=color:#f92672>+</span>b)<span style=color:#f92672>%</span>p)
</span></span><span style=display:flex><span>c<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> c<span style=color:#f92672>&lt;</span>len(flag):
</span></span><span style=display:flex><span>	X<span style=color:#f92672>.</span>append((a<span style=color:#f92672>*</span>X[c]<span style=color:#f92672>+</span>b)<span style=color:#f92672>%</span>p)
</span></span><span style=display:flex><span>	c<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>output<span style=color:#f92672>=</span>[]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(flag)):
</span></span><span style=display:flex><span>	output<span style=color:#f92672>.</span>append(ord(flag[i])<span style=color:#f92672>^</span>X[i])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print (output)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#output:[6680465291011788243L, 5100570103593250421L, 5906808313299165060L, 1965917782737693358L, 9056785591048864624L, 1829758495155458576L, 6790868899161600055L, 1596515234863242823L, 1542626304251881891L, 8104506805098882719L, 1007224930233032567L, 3734079115803760073L, 7849173324645439452L, 8732100672289854567L, 5175836768003400781L, 1424151033239111460L, 1199105222454059911L, 1664215650827157105L, 9008386209424299800L, 484211781780518254L, 2512932525834758909L, 270126439443651096L, 3183206577049996011L, 3279047721488346724L, 3454276445316959481L, 2818682432513461896L, 1198230090827197024L, 6998819122186572678L, 9203565046169681246L, 2238598386754583423L, 467098371562174956L, 5653529053698720276L, 2015452976526330232L, 2551998512666399199L, 7069788985925185031L, 5960242873564733830L, 8674335448210427234L, 8831855692621741517L, 6943582577462564728L, 2159276184039111694L, 8688468346396385461L, 440650407436900405L, 6995840816131325250L, 4637034747767556143L, 3074066864500201630L, 3089580429060692934L, 2636919931902761401L, 5048459994558771200L, 6575450200614822046L, 666932631675155892L, 3355067815387388102L, 3494943856508019168L, 3208598838604422062L, 1651654978658074504L, 1031697828323732832L, 3522460087077276636L, 6871524519121580258L, 6523448658792083486L, 127306226106122213L, 147467006327822722L, 3241736541061054362L, 8781435214433157730L, 7267936298215752831L, 3411059229428517472L, 6597995245035183751L, 1256684894889830824L, 6272257692365676430L, 303437276610446361L, 8730871523914292433L, 6472487383860532571L, 5022165523149187811L, 4462701447753878703L, 1590013093628585660L, 4874224067795612706L]</span>
</span></span></code></pre></div><p>The idea to solve the challenge is very simple, if we can find <code>X</code> and XOR it with the given <code>output</code> we get the flag.</p><p>After going through the code, I got to know that it involves randombits, the topic which I&rsquo;ve never solved any challenge based on it. But I know that it is related to <a href=https://en.wikipedia.org/wiki/Pseudorandom_number_generator>Pseudo Random Number Generator</a>(PRNG). Anyways, lets break the code into parts and understand it.
First lets understand the final part of the code,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>output<span style=color:#f92672>=</span>[]
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(flag)):
</span></span><span style=display:flex><span>	output<span style=color:#f92672>.</span>append(ord(flag[i])<span style=color:#f92672>^</span>X[i])
</span></span><span style=display:flex><span>print (output)
</span></span></code></pre></div><p>We understood that, <code>flag</code> and an array <code>X</code> were XORed and appended to <code>output</code> array. Here, we only know <code>output</code>, <code>X</code> & <code>flag</code> are yet to be found.
Guess what?
Since we know the flag format we can find some values of <code>X</code>,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;FwordCTF{&#34;</span>
</span></span><span style=display:flex><span>output <span style=color:#f92672>=</span> [<span style=color:#ae81ff>6680465291011788243</span>, <span style=color:#ae81ff>5100570103593250421</span>, <span style=color:#ae81ff>5906808313299165060</span>, <span style=color:#ae81ff>1965917782737693358</span>, <span style=color:#ae81ff>9056785591048864624</span>, <span style=color:#ae81ff>1829758495155458576</span>, <span style=color:#ae81ff>6790868899161600055</span>, <span style=color:#ae81ff>1596515234863242823</span>, <span style=color:#ae81ff>1542626304251881891</span>, <span style=color:#ae81ff>8104506805098882719</span>, <span style=color:#ae81ff>1007224930233032567</span>, <span style=color:#ae81ff>3734079115803760073</span>, <span style=color:#ae81ff>7849173324645439452</span>, <span style=color:#ae81ff>8732100672289854567</span>, <span style=color:#ae81ff>5175836768003400781</span>, <span style=color:#ae81ff>1424151033239111460</span>, <span style=color:#ae81ff>1199105222454059911</span>, <span style=color:#ae81ff>1664215650827157105</span>, <span style=color:#ae81ff>9008386209424299800</span>, <span style=color:#ae81ff>484211781780518254</span>, <span style=color:#ae81ff>2512932525834758909</span>, <span style=color:#ae81ff>270126439443651096</span>, <span style=color:#ae81ff>3183206577049996011</span>, <span style=color:#ae81ff>3279047721488346724</span>, <span style=color:#ae81ff>3454276445316959481</span>, <span style=color:#ae81ff>2818682432513461896</span>, <span style=color:#ae81ff>1198230090827197024</span>, <span style=color:#ae81ff>6998819122186572678</span>, <span style=color:#ae81ff>9203565046169681246</span>, <span style=color:#ae81ff>2238598386754583423</span>, <span style=color:#ae81ff>467098371562174956</span>, <span style=color:#ae81ff>5653529053698720276</span>, <span style=color:#ae81ff>2015452976526330232</span>, <span style=color:#ae81ff>2551998512666399199</span>, <span style=color:#ae81ff>7069788985925185031</span>, <span style=color:#ae81ff>5960242873564733830</span>, <span style=color:#ae81ff>8674335448210427234</span>, <span style=color:#ae81ff>8831855692621741517</span>, <span style=color:#ae81ff>6943582577462564728</span>, <span style=color:#ae81ff>2159276184039111694</span>, <span style=color:#ae81ff>8688468346396385461</span>, <span style=color:#ae81ff>440650407436900405</span>, <span style=color:#ae81ff>6995840816131325250</span>, <span style=color:#ae81ff>4637034747767556143</span>, <span style=color:#ae81ff>3074066864500201630</span>, <span style=color:#ae81ff>3089580429060692934</span>, <span style=color:#ae81ff>2636919931902761401</span>, <span style=color:#ae81ff>5048459994558771200</span>, <span style=color:#ae81ff>6575450200614822046</span>, <span style=color:#ae81ff>666932631675155892</span>, <span style=color:#ae81ff>3355067815387388102</span>, <span style=color:#ae81ff>3494943856508019168</span>, <span style=color:#ae81ff>3208598838604422062</span>, <span style=color:#ae81ff>1651654978658074504</span>, <span style=color:#ae81ff>1031697828323732832</span>, <span style=color:#ae81ff>3522460087077276636</span>, <span style=color:#ae81ff>6871524519121580258</span>, <span style=color:#ae81ff>6523448658792083486</span>, <span style=color:#ae81ff>127306226106122213</span>, <span style=color:#ae81ff>147467006327822722</span>, <span style=color:#ae81ff>3241736541061054362</span>, <span style=color:#ae81ff>8781435214433157730</span>, <span style=color:#ae81ff>7267936298215752831</span>, <span style=color:#ae81ff>3411059229428517472</span>, <span style=color:#ae81ff>6597995245035183751</span>, <span style=color:#ae81ff>1256684894889830824</span>, <span style=color:#ae81ff>6272257692365676430</span>, <span style=color:#ae81ff>303437276610446361</span>, <span style=color:#ae81ff>8730871523914292433</span>, <span style=color:#ae81ff>6472487383860532571</span>,<span style=color:#ae81ff>5022165523149187811</span>, <span style=color:#ae81ff>4462701447753878703</span>, <span style=color:#ae81ff>1590013093628585660</span>, <span style=color:#ae81ff>4874224067795612706</span>]  
</span></span><span style=display:flex><span>X <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(flag)):
</span></span><span style=display:flex><span>    X<span style=color:#f92672>.</span>append(ord(flag[i])<span style=color:#f92672>^</span>output[i])
</span></span></code></pre></div><p>Here is the output,</p><pre tabindex=0><code>In [2]: X
Out[2]: 
[6680465291011788181,
 5100570103593250306,
 5906808313299165163,
 1965917782737693404,
 9056785591048864532,
 1829758495155458643,
 6790868899161600099,
 1596515234863242753,
 1542626304251881944]
</code></pre><p>Now lets find the remaining values of <code>X</code> by analysing the code involved in forming it,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>p<span style=color:#f92672>=</span>getPrime(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>a<span style=color:#f92672>=</span>getrandbits(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>b<span style=color:#f92672>=</span>getrandbits(<span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>X<span style=color:#f92672>=</span>[]
</span></span><span style=display:flex><span>X<span style=color:#f92672>.</span>append((a<span style=color:#f92672>*</span>getrandbits(<span style=color:#ae81ff>64</span>)<span style=color:#f92672>+</span>b)<span style=color:#f92672>%</span>p)
</span></span><span style=display:flex><span>c<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> c<span style=color:#f92672>&lt;</span>len(flag):
</span></span><span style=display:flex><span>	X<span style=color:#f92672>.</span>append((a<span style=color:#f92672>*</span>X[c]<span style=color:#f92672>+</span>b)<span style=color:#f92672>%</span>p)
</span></span><span style=display:flex><span>	c<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>We understood that <code>p</code> is a random <strong>prime number</strong>, <code>a</code> & <code>b</code> are any two random numbers. Also we can understand that, this <code>a*getrandbits(64)+b)%p</code> is the part which is producing <code>X[i]</code>. But at first it seeded an initial value into <code>X</code>. Now, for any noob like me two questions will arise,</p><p><strong>[1] What is the type of PRNG used?</strong></p><p><strong>[2] How to crack it?</strong></p><p>So, I have googled for list of PRNG&rsquo;s. I got the list <a href=https://en.wikipedia.org/wiki/List_of_random_number_generators>here</a>. My idea is to google each Random Number Generator(RNG) and finding similarity to our code. Fortunately, I found it. It is <a href=https://en.wikipedia.org/wiki/Linear_congruential_generator>Linear Congruential Generator</a>(LCG).</p><p>This equation confirmed me that it is an LCG,</p><p>$$ (X_{n+1}) = (aX_{n}+c)\pmod m $$</p><h3 id=cracking-lcg>Cracking LCG<a hidden class=anchor aria-hidden=true href=#cracking-lcg>#</a></h3><p>I have referred to many articles to find the answer for the 2nd question, and I got to know that LCG is the easiest of all PRNG&rsquo;s for both implementing & cracking. Let&rsquo;s crack it,
Let us understand the terminology here,<br><code>p</code> - modulus<br><code>a</code> - multiplier<br><code>b</code> - increment<br>Unfortunately, We don&rsquo;t the values of all the three. Let us understand this <code>a*getrandbits(64)+b)%p</code> working,</p><pre tabindex=0><code>s1 = s0*a + b  (mod p)
s2 = s1*a + b  (mod p)
s3 = s2*a + b  (mod p)
</code></pre><p>Its feeding back the intial seed to find the next one. Next one to find the next one & so on. Let us rearrange the equations a bit,</p><pre tabindex=0><code>s1 - (s0*a + b) = k_1 * p
s2 - (s1*a + b) = k_2 * p
s3 - (s2*a + b) = k_3 * p
</code></pre><p>Its unreal to solve 3 equations with 6 unknowns, but number theory made it real by using simple property i.e., if we have few random multiples of p, with large probability their gcd will be equal to p.
Let us manipulate the above equations a bit,</p><pre tabindex=0><code>t0 = s1 - s0
t1 = s2 - s1 = (s1*a + b) - (s0*a + b) = a*(s1 - s0) = a*t0 (mod p)
t2 = s3 - s2 = (s2*a + b) - (s1*a + b) = a*(s2 - s1) = a*t1 (mod p)
t3 = s4 - s3 = (s3*a + b) - (s2*a + b) = a*(s3 - s2) = a*t2 (mod p)
</code></pre><p>Final equation to solve this is,</p><pre tabindex=0><code>t2*t0 - t1*t1 = (a*a*t0 * t0) - (a*t0 * a*t0) = 0 (mod p)
</code></pre><p>Let us define python function to crack the modulus,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crack_unknown_modulus</span>(states):
</span></span><span style=display:flex><span>    diffs <span style=color:#f92672>=</span> [s1 <span style=color:#f92672>-</span> s0 <span style=color:#66d9ef>for</span> s0, s1 <span style=color:#f92672>in</span> zip(states, states[<span style=color:#ae81ff>1</span>:])]
</span></span><span style=display:flex><span>    zeroes <span style=color:#f92672>=</span> [t2<span style=color:#f92672>*</span>t0 <span style=color:#f92672>-</span> t1<span style=color:#f92672>*</span>t1 <span style=color:#66d9ef>for</span> t0, t1, t2 <span style=color:#f92672>in</span> zip(diffs, diffs[<span style=color:#ae81ff>1</span>:], diffs[<span style=color:#ae81ff>2</span>:])]
</span></span><span style=display:flex><span>    modulus <span style=color:#f92672>=</span> abs(reduce(gcd, zeroes))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> modulus
</span></span></code></pre></div><p>Now we got the modulus, its pretty simple to find multiplier & increment. Let us consider the first two equations and subtract them</p><pre tabindex=0><code>s1 = x0*a + b  (mod p)
s_2 = x1*a + b  (mod p)

s_2 - s_1 = s1*a - s0*a  (mod p)
s_2 - s_1 = a*(s1 - s0)  (mod p)
a = (s_2 - s_1)/(s_1 - s_0)  (mod p)
</code></pre><p>that&rsquo;s it we got <code>a</code> and now <code>b</code> can be retrieved by by using only one equation as we know all other values in the equation. Consider the first equation,</p><pre tabindex=0><code>s1 = s0*a + b   (mod p)
</code></pre><p>After rearranging,</p><pre tabindex=0><code>b  = s1 - s0*a  (mod p)
</code></pre><p>Let us put this in a function,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crack_lcg</span>(seeds):
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> ((seeds[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>-</span> seeds[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>*</span> invert(seeds[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> seeds[<span style=color:#ae81ff>0</span>], p)) <span style=color:#f92672>%</span> p 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a, (seeds[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> seeds[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>a) <span style=color:#f92672>%</span> p
</span></span></code></pre></div><h3 id=final-exploit>Final Exploit<a hidden class=anchor aria-hidden=true href=#final-exploit>#</a></h3><p>Wrapping up everything from all the understanding we got from the above discussion,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> reduce
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> gmpy2 <span style=color:#f92672>import</span> gcd,gcdext,invert
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crack_lcg</span>(seeds):
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> ((seeds[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>-</span> seeds[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>*</span> invert(seeds[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> seeds[<span style=color:#ae81ff>0</span>], p)) <span style=color:#f92672>%</span> p 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a, (seeds[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> seeds[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>a) <span style=color:#f92672>%</span> p
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crack_unknown_modulus</span>(states):
</span></span><span style=display:flex><span>    diffs <span style=color:#f92672>=</span> [s1 <span style=color:#f92672>-</span> s0 <span style=color:#66d9ef>for</span> s0, s1 <span style=color:#f92672>in</span> zip(states, states[<span style=color:#ae81ff>1</span>:])]
</span></span><span style=display:flex><span>    zeroes <span style=color:#f92672>=</span> [t2<span style=color:#f92672>*</span>t0 <span style=color:#f92672>-</span> t1<span style=color:#f92672>*</span>t1 <span style=color:#66d9ef>for</span> t0, t1, t2 <span style=color:#f92672>in</span> zip(diffs, diffs[<span style=color:#ae81ff>1</span>:], diffs[<span style=color:#ae81ff>2</span>:])]
</span></span><span style=display:flex><span>    modulus <span style=color:#f92672>=</span> abs(reduce(gcd, zeroes))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> modulus
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;FwordCTF{&#34;</span>
</span></span><span style=display:flex><span>output <span style=color:#f92672>=</span> [<span style=color:#ae81ff>6680465291011788243</span>, <span style=color:#ae81ff>5100570103593250421</span>, <span style=color:#ae81ff>5906808313299165060</span>, <span style=color:#ae81ff>1965917782737693358</span>, <span style=color:#ae81ff>9056785591048864624</span>, <span style=color:#ae81ff>1829758495155458576</span>, <span style=color:#ae81ff>6790868899161600055</span>, <span style=color:#ae81ff>1596515234863242823</span>, <span style=color:#ae81ff>1542626304251881891</span>, <span style=color:#ae81ff>8104506805098882719</span>, <span style=color:#ae81ff>1007224930233032567</span>, <span style=color:#ae81ff>3734079115803760073</span>, <span style=color:#ae81ff>7849173324645439452</span>, <span style=color:#ae81ff>8732100672289854567</span>, <span style=color:#ae81ff>5175836768003400781</span>, <span style=color:#ae81ff>1424151033239111460</span>, <span style=color:#ae81ff>1199105222454059911</span>, <span style=color:#ae81ff>1664215650827157105</span>, <span style=color:#ae81ff>9008386209424299800</span>, <span style=color:#ae81ff>484211781780518254</span>, <span style=color:#ae81ff>2512932525834758909</span>, <span style=color:#ae81ff>270126439443651096</span>, <span style=color:#ae81ff>3183206577049996011</span>, <span style=color:#ae81ff>3279047721488346724</span>, <span style=color:#ae81ff>3454276445316959481</span>, <span style=color:#ae81ff>2818682432513461896</span>, <span style=color:#ae81ff>1198230090827197024</span>, <span style=color:#ae81ff>6998819122186572678</span>, <span style=color:#ae81ff>9203565046169681246</span>, <span style=color:#ae81ff>2238598386754583423</span>, <span style=color:#ae81ff>467098371562174956</span>, <span style=color:#ae81ff>5653529053698720276</span>, <span style=color:#ae81ff>2015452976526330232</span>, <span style=color:#ae81ff>2551998512666399199</span>, <span style=color:#ae81ff>7069788985925185031</span>, <span style=color:#ae81ff>5960242873564733830</span>, <span style=color:#ae81ff>8674335448210427234</span>, <span style=color:#ae81ff>8831855692621741517</span>, <span style=color:#ae81ff>6943582577462564728</span>, <span style=color:#ae81ff>2159276184039111694</span>, <span style=color:#ae81ff>8688468346396385461</span>, <span style=color:#ae81ff>440650407436900405</span>, <span style=color:#ae81ff>6995840816131325250</span>, <span style=color:#ae81ff>4637034747767556143</span>, <span style=color:#ae81ff>3074066864500201630</span>, <span style=color:#ae81ff>3089580429060692934</span>, <span style=color:#ae81ff>2636919931902761401</span>, <span style=color:#ae81ff>5048459994558771200</span>, <span style=color:#ae81ff>6575450200614822046</span>, <span style=color:#ae81ff>666932631675155892</span>, <span style=color:#ae81ff>3355067815387388102</span>, <span style=color:#ae81ff>3494943856508019168</span>, <span style=color:#ae81ff>3208598838604422062</span>, <span style=color:#ae81ff>1651654978658074504</span>, <span style=color:#ae81ff>1031697828323732832</span>, <span style=color:#ae81ff>3522460087077276636</span>, <span style=color:#ae81ff>6871524519121580258</span>, <span style=color:#ae81ff>6523448658792083486</span>, <span style=color:#ae81ff>127306226106122213</span>, <span style=color:#ae81ff>147467006327822722</span>, <span style=color:#ae81ff>3241736541061054362</span>, <span style=color:#ae81ff>8781435214433157730</span>, <span style=color:#ae81ff>7267936298215752831</span>, <span style=color:#ae81ff>3411059229428517472</span>, <span style=color:#ae81ff>6597995245035183751</span>, <span style=color:#ae81ff>1256684894889830824</span>, <span style=color:#ae81ff>6272257692365676430</span>, <span style=color:#ae81ff>303437276610446361</span>, <span style=color:#ae81ff>8730871523914292433</span>, <span style=color:#ae81ff>6472487383860532571</span>,<span style=color:#ae81ff>5022165523149187811</span>, <span style=color:#ae81ff>4462701447753878703</span>, <span style=color:#ae81ff>1590013093628585660</span>, <span style=color:#ae81ff>4874224067795612706</span>]  
</span></span><span style=display:flex><span>X <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(flag)):
</span></span><span style=display:flex><span>    X<span style=color:#f92672>.</span>append(ord(flag[i])<span style=color:#f92672>^</span>output[i])
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> crack_unknown_modulus(X)
</span></span><span style=display:flex><span>a, b <span style=color:#f92672>=</span> crack_lcg(X)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>,len(X)):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>assert</span> X[i] <span style=color:#f92672>==</span> (X[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>a <span style=color:#f92672>+</span> b) <span style=color:#f92672>%</span> p
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>s<span style=color:#f92672>.</span>append(X[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>,len(output)):
</span></span><span style=display:flex><span>	s<span style=color:#f92672>.</span>append((s[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>a <span style=color:#f92672>+</span> b)<span style=color:#f92672>%</span>p)
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(output)):
</span></span><span style=display:flex><span>	flag<span style=color:#f92672>+=</span> chr(s[i]<span style=color:#f92672>^</span>output[i])
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[+] Flag: &#34;</span>,flag)
</span></span></code></pre></div><p><strong>Flag:</strong> <code>FwordCTF{LCG_easy_to_break!That_was_a_mistake_choosing_it_as_a_secure_way}</code></p><p>You can find my entire exploit <a href=https://github.com/malladisiddu/Crypto-writeups/blob/master/FwordCTF/Randomness/lcgcrack.py>here</a>. If you have any queries, feedback, suggestions either you can put them in comment section or you can ping me via twitter <a href=https://twitter.com/st0ic3r>@st0ic3r</a>.</p><p>Alright, See you next time</p><p>Bu, Bye !</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://malladisiddu.github.io/tags/lcg/>LCG</a></li><li><a href=https://malladisiddu.github.io/tags/prng/>PRNG</a></li></ul><nav class=paginav><a class=prev href=https://malladisiddu.github.io/posts/bsides-delhi-ctf-2020/><span class=title>« Prev</span><br><span>BSides Delhi CTF - 2020</span></a>
<a class=next href=https://malladisiddu.github.io/posts/arab-security-cyber-wargames/><span class=title>Next »</span><br><span>Arab Security Cyber Wargames</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on twitter" href="https://twitter.com/intent/tweet/?text=FwordCTF%202020&amp;url=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f&amp;hashtags=LCG%2cPRNG"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f&amp;title=FwordCTF%202020&amp;summary=FwordCTF%202020&amp;source=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f&title=FwordCTF%202020"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on whatsapp" href="https://api.whatsapp.com/send?text=FwordCTF%202020%20-%20https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on telegram" href="https://telegram.me/share/url?text=FwordCTF%202020&amp;url=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share FwordCTF 2020 on ycombinator" href="https://news.ycombinator.com/submitlink?t=FwordCTF%202020&u=https%3a%2f%2fmalladisiddu.github.io%2fposts%2ffwordctf-2020-writeups%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://malladisiddu.github.io/>Siddartha's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>